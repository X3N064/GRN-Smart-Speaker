"use strict";
/**
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This file implements propagation for the Stackdriver Trace v1 Trace Context
 * format.
 * Full details at https://cloud.google.com/trace/docs/support.
 */
const crypto = require("crypto");
const hex2dec_1 = require("hex2dec");
const uuid = require("uuid");
const TRACE_CONTEXT_HEADER_NAME = 'x-cloud-trace-context';
function parseContextFromHeader(str) {
    if (typeof str !== 'string') {
        return null;
    }
    const matches = str.match(/^([0-9a-fA-F]+)(?:\/([0-9]+))(?:;o=(.*))?/);
    if (!matches ||
        matches.length !== 4 ||
        matches[0] !== str ||
        (matches[2] && isNaN(Number(matches[2])))) {
        return null;
    }
    return {
        traceId: matches[1],
        // strip 0x prefix from hex output from decToHex, and and pad so it's always
        // a length-16 hex string
        spanId: `0000000000000000${hex2dec_1.decToHex(matches[2]).slice(2)}`.slice(-16),
        options: isNaN(Number(matches[3])) ? undefined : Number(matches[3]),
    };
}
exports.parseContextFromHeader = parseContextFromHeader;
function serializeSpanContext(spanContext) {
    let header = `${spanContext.traceId}/${hex2dec_1.hexToDec(spanContext.spanId)}`;
    if (spanContext.options) {
        header += `;o=${spanContext.options}`;
    }
    return header;
}
exports.serializeSpanContext = serializeSpanContext;
function extract(getter) {
    return parseContextFromHeader(getter.getHeader(TRACE_CONTEXT_HEADER_NAME));
}
exports.extract = extract;
function inject(setter, spanContext) {
    setter.setHeader(TRACE_CONTEXT_HEADER_NAME, serializeSpanContext(spanContext));
}
exports.inject = inject;
const SPAN_ID_RANDOM_BYTES = 8;
// Use the faster crypto.randomFillSync when available (Node 7+) falling back to
// using crypto.randomBytes.
// TODO(ofrobots): Use alternate logic for the browser where crypto and Buffer
//    are not available.
const spanIdBuffer = Buffer.alloc(SPAN_ID_RANDOM_BYTES);
const randomFillSync = crypto.randomFillSync;
const randomBytes = crypto.randomBytes;
const spanRandomBuffer = randomFillSync
    ? () => randomFillSync(spanIdBuffer)
    : () => randomBytes(SPAN_ID_RANDOM_BYTES);
function generate() {
    return {
        traceId: uuid
            .v4()
            .split('-')
            .join(''),
        spanId: spanRandomBuffer().toString('hex'),
    };
}
exports.generate = generate;
//# sourceMappingURL=v1.js.map