"use strict";
/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.conversation = exports.UnauthorizedError = void 0;
const assistant_1 = require("../assistant");
const conv_1 = require("./conv");
const common = require("../common");
const auth_1 = require("../auth");
const logger_1 = require("../logger");
const google_auth_library_1 = require("google-auth-library");
/**
 * Throw an UnauthorizedError in an intent handler that requires an access token if the token is
 * invalid. This triggers an access token refresh request for the Action from the Assistant.
 *
 * @example
 * ```javascript
 * const app = conversation()
 *
 * app.handle('My_Handler_Name_That_Requires_An_Access_Token', conv => {
 *   // ...
 *
 *   // given a function to check if an access token is still valid
 *   const valid = isTokenValid(conv.user.params.bearerToken)
 *   if (!valid) {
 *     throw new UnauthorizedError()
 *   }
 * })
 *
 * ```
 *
 * @public
 */
class UnauthorizedError extends Error {
}
exports.UnauthorizedError = UnauthorizedError;
/**
 * This is the function that creates the app instance which on new requests,
 * creates a way to interact with the conversation API directly from Assistant,
 * providing implementation for all the methods available in the API.
 *
 * @example
 * ```javascript
 *
 * const app = conversation()
 *
 * app.handler('handler name', conv => {
 *   conv.add('How are you?')
 * })
 * ```
 *
 * @public
 */
exports.conversation = (options = {}) => {
    if (options.debug && !options.logger) {
        // Use special logger where `debug` messages are now `info` level
        logger_1.setLogger(logger_1.debugLogger);
    }
    else {
        logger_1.setLogger(options.logger);
    }
    const app = assistant_1.attach({
        _internal: {
            handlers: {
                handles: {},
                catcher: (conv, e) => {
                    throw e;
                },
            },
            middlewares: [],
        },
        handle(names, handler) {
            for (const name of common.toArray(names)) {
                this._internal.handlers.handles[name] = handler;
            }
            return this;
        },
        catch(catcher) {
            this._internal.handlers.catcher = catcher;
            return this;
        },
        middleware(middleware) {
            this._internal.middlewares.push(middleware);
            return this;
        },
        verification: options.verification,
        _client: (options.verification || options.clientId) ?
            new google_auth_library_1.OAuth2Client(options.clientId) : undefined,
        async handler(body, headers, metadata = {}) {
            const { clientId, verification } = this;
            if (verification) {
                const { project, status = 403, error = (e) => e, } = typeof verification === 'string' ? { project: verification } : verification;
                const token = headers['google-assistant-signature'];
                try {
                    await this._client.verifyIdToken({
                        idToken: token,
                        audience: project,
                    });
                }
                catch (e) {
                    return {
                        status,
                        body: {
                            error: typeof error === 'string' ? error :
                                error(`ID token verification failed: ${e.stack || e.message || e}`),
                        },
                    };
                }
            }
            let conv = new conv_1.ConversationV3({
                body,
                headers,
            });
            if (headers.authorization && typeof headers.authorization === 'string') {
                const authHeaderProcessor = new auth_1.AuthHeaderProcessor();
                conv.user = await conv.user.processAuthHeader(headers.authorization, authHeaderProcessor, clientId);
            }
            for (const middleware of this._internal.middlewares) {
                const result = middleware(conv, metadata);
                conv = (result instanceof conv_1.ConversationV3 ? result : ((await result) || conv));
            }
            logger_1.getLogger().debug('ConversationV3', common.stringify(conv, 'request', 'headers', 'body'));
            const handlerName = conv.handler.name;
            const handler = this._internal.handlers.handles[handlerName];
            if (typeof handler === 'undefined') {
                throw new Error(`Handler not found for handle name: ${handlerName}`);
            }
            try {
                try {
                    await handler(conv);
                }
                catch (e) {
                    await this._internal.handlers.catcher(conv, e);
                }
            }
            catch (e) {
                if (e instanceof UnauthorizedError) {
                    return {
                        status: 401,
                        headers: {},
                        body: {},
                    };
                }
                throw e;
            }
            return {
                status: 200,
                headers: {},
                body: conv.serialize(),
            };
        },
    }, options);
    app.handle('actions.handler.HEALTH_CHECK', conv => {
        conv.json({});
    });
    return app;
};
//# sourceMappingURL=conversation.js.map