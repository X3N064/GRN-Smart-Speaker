"use strict";
/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationV3 = void 0;
const prompt_1 = require("./prompt");
const common_1 = require("../common");
const handler_1 = require("./handler");
const context_1 = require("./handler/context");
/**
 * Represents a turn of the conversation. This is provided as `conv` in an
 * intent handler.
 * @public
 */
class ConversationV3 {
    /**
     * Initializes conversational application.
     * @param options A set of options that apply to the application.
     * @public
     */
    constructor(options = {}) {
        /** @public */
        this.overwrite = true;
        /** @public */
        this.digested = false;
        const { headers = {}, body = {} } = options;
        this.request = body;
        this.headers = headers;
        this.handler = new handler_1.Handler(body.handler);
        this.intent = new handler_1.Intent(body.intent);
        this.scene = new handler_1.Scene(body.scene);
        this.session = new handler_1.Session(body.session);
        this.user = new handler_1.User(body.user);
        this.device = new handler_1.Device(body.device);
        this.home = new handler_1.Home(body.home);
        this.expected = new handler_1.Expected();
        this.context = new context_1.Context(body.context);
        this.prompt = new prompt_1.Prompt();
        // Create a instance of prompt to keep track of prompts to be sent.
        // Set request values to compare later to see what the developer changed
        this._internal = {
            promptSet: false,
            orig: {
                scene: common_1.clone(this.scene),
                session: common_1.clone(this.session),
                user: common_1.clone(this.user),
                home: common_1.clone(this.home),
            },
        };
    }
    /**
     * Manually sets response JSON.
     * @public
     */
    json(json) {
        this._internal.raw = json;
        return this;
    }
    /**
     * Add prompt items to be sent back for fulfillment.
     *
     * Prompt items are limited to 2 simple responses.
     * More than 2 will result in an error in fulfillment.
     * The first simple added in order will be set to `firstSimple`.
     * The last simple added in order will be set to `lastSimple`.
     *
     * @example
     * ```javascript
     *
     * const app = conversation()
     *
     * app.handle('main', conv => {
     *   const ssml = '<speak>Hi! <break time="1"/> ' +
     *     'I can read out an ordinal like <say-as interpret-as="ordinal">123</say-as>. ' +
     *     'Say a number.</speak>'
     *   conv.add(ssml)
     * })
     * ```
     *
     * @param promptItems A response fragment for the library to construct a single complete response
     * @public
     */
    add(...promptItems) {
        if (this.digested) {
            throw new Error('Response has already been sent. ' +
                'Is this being used in an async call that was not ' +
                'returned as a promise to the intent handler?');
        }
        this.prompt.add(...promptItems);
        this._internal.promptSet = true;
        return this;
    }
    /**
     * Append speech responses to be sent back for fulfillment.
     *
     * @example
     * ```javascript
     *
     * const app = conversation()
     *
     * app.handle('handler name', conv => {
     *   const ssml = '<speak>Hi! <break time="1"/> ' +
     *     'I can read out an ordinal like <say-as interpret-as="ordinal">123</say-as>. ' +
     *     'Say a number.</speak>'
     *   conv.append(ssml)
     * })
     * ```
     *
     * @param speech A speech string to be appended
     * @public
     */
    append(speech) {
        if (this.digested) {
            throw new Error('Response has already been sent. ' +
                'Is this being used in an async call that was not ' +
                'returned as a promise to the intent handler?');
        }
        this.prompt.append(speech);
        this._internal.promptSet = true;
        return this;
    }
    /**
     * Returns generated JSON response.
     *
     * Note this method sets the `digested` field to `true` and can only be
     * called once.
     * @public
     */
    response() {
        if (this.digested) {
            throw new Error('Response has already been digested');
        }
        this.digested = true;
        const session = new handler_1.Session(this.session);
        if (session.typeOverrides.length) {
            for (const override of session.typeOverrides) {
                if (override.mode) {
                    // Temporarily use typeOverrideMode property for mode until
                    // typeOverrideMode is fully deleted and migrated out
                    override.typeOverrideMode = override.mode;
                    delete override.mode;
                }
            }
        }
        else {
            delete session.typeOverrides;
        }
        // Create response and include field that should be included in every response
        const response = {
            // Echo back session variables in response
            session,
        };
        // Add other attributes to response if they exist and are different form the request
        if (!this.overwrite) {
            this.prompt.override = false;
        }
        response.prompt = new prompt_1.Prompt(this.prompt);
        if (this.scene && !common_1.isJsonEqual(Object.assign({}, this.scene), Object.assign({}, this._internal.orig.scene))) {
            response.scene = new handler_1.Scene(this.scene);
        }
        if (this.user && !common_1.isJsonEqual(Object.assign({}, this.user), Object.assign({}, this._internal.orig.user))) {
            response.user = new handler_1.User(this.user);
        }
        if (this.home && !common_1.isJsonEqual(Object.assign({}, this.home), Object.assign({}, this._internal.orig.home))) {
            response.home = new handler_1.Home(this.home);
        }
        if (this.expected.languageCode ||
            (this.expected.speech && this.expected.speech.length)) {
            response.expected = this.expected;
            if (this.expected.speech && !this.expected.speech.length) {
                delete response.expected.speech;
            }
        }
        return common_1.clone(response);
    }
    /**
     * Returns manually set JSON response or generates a response.
     *
     * If the response has to be generated, it sets the `digested` field to
     * `true`.
     * @public
     */
    serialize() {
        if (this._internal.raw) {
            return this._internal.raw;
        }
        const handlerResponse = this.response();
        return handlerResponse;
    }
}
exports.ConversationV3 = ConversationV3;
//# sourceMappingURL=conv.js.map